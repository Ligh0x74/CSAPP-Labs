phase_1:
(1)输入命令:x/64bc 0x402400 => key

phase_2:
(1)输入命令:x/64bc 0x4025c3 => format
(2)伪代码:
   char *rsp = %rsp;
   sscanf("1 2 4 8 16 32", "%d %d %d %d %d %d", rsp, rsp + 4, rsp + 8, rsp + 12, rsp + 16, rsp + 20);

phase_3:
(1)输入命令:x/64bc 0x4025cf => format
(2)伪代码:
   char *rsp = %rsp;
   sscanf("? ?", "%d %d", rsp + 8, rsp + 12);
(3)GDB输入命令:x/64bx 0x402470 => jmp 0x400f7c
(4)得出答案:0 207

phase_4:
(1)输入命令:x/64bc 0x4025cf => format
(2)伪代码:
   char *rsp = %rsp;
   sscanf("? 0", "%d %d", rsp + 8, rsp + 12);
(3)func4() return 0 的情况:
   14 >> 1 = 7
   (7 - 1) >> 1 = 3
   (3 - 1) >> 1 = 1
   (1 - 1) >> 1 = 0
(4)得出答案:? 0 #? ∈ {0, 1, 3, 7}

phase_5:
(1)输入命令:x/64bc 0x4024b0
(2)输入命令:x/64bc 0x40245e => flyers
(3)伪代码:
   char arr[6];
   0x4024b0(arr[?] & 0xf) => flyers
   arr[0-5] & 0xf => 0x9 0xf 0xe 0x5 0x6 0x7
(4)得出答案:ionefg #多种答案

phase_6:
（1）输入6个不相同的数x[i],并且使得x[i] ∈ [1, 6]
(2)进行运算,使 x[i] = 7 - x[i].
(3)将 0x6032d0 与 1 对应,0x6032e0 与 2 对应,以此类推直到 0x603320,并将地址值按照输入的数字顺序来排列.
(4)依次取出排列后的地址对应的值,结果必须从大到小排列,输入命令:x/12gx 0x6032d0,期望结果如下.
    0x6032d0:    0x????????0000014c    0x00000000006032e0
    0x6032e0:    0x????????000000a8    0x0000000000000000
    0x6032f0:    0x????????0000039c    0x0000000000603300
    0x603300:    0x????????000002b3    0x0000000000603310
    0x603310:    0x????????000001dd    0x0000000000603320
    0x603320:    0x????????000001bb    0x00000000006032d0
(5)反向推导得出答案:3 4 5 6 1 2 => 4 3 2 1 6 5

ps:寄存器和跳转指令好多啊,头晕!!!
