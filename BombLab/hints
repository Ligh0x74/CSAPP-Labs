phase_1(比较):
(1)输入命令:x/s 0x402400 => key

phase_2(循环):
(1)输入命令:x/s 0x4025c3 => format
(2)伪代码:
   char *rsp = %rsp;
   sscanf("1 2 4 8 16 32", "%d %d %d %d %d %d", rsp, rsp + 4, rsp + 8, rsp + 12, rsp + 16, rsp + 20);

phase_3（switch）:
(1)输入命令:x/s 0x4025cf => format
(2)伪代码:
   char *rsp = %rsp;
   sscanf("? ?", "%d %d", rsp + 8, rsp + 12);
(3)GDB输入命令:x/a 0x402470 => jmp 0x400f7c(多种答案)
(4)得出答案:0 207

phase_4（递归）:
(1)输入命令:x/s 0x4025cf => format
(2)伪代码:
   char *rsp = %rsp;
   sscanf("? 0", "%d %d", rsp + 8, rsp + 12);
(3)func4() return 0 的情况:
   14 >> 1 = 7
   (7 - 1) >> 1 = 3
   (3 - 1) >> 1 = 1
   (1 - 1) >> 1 = 0
(4)得出答案:? 0 #? ∈ {0, 1, 3, 7}

phase_5（键值映射）:
(1)输入命令:x/16c 0x4024b0
(2)输入命令:x/s 0x40245e => flyers
(3)伪代码:
   char arr[6];
   0x4024b0(arr[?] & 0xf) => flyers
   arr[0-5] & 0xf => 0x9 0xf 0xe 0x5 0x6 0x7
(4)得出答案:ionefg #多种答案

phase_6（链表排序）:
（1）输入6个不相同的数x[i],并且使得x[i] ∈ [1, 6]
(2)进行运算,使 x[i] = 7 - x[i].
(3)将 0x6032d0 与 1 对应,0x6032e0 与 2 对应,以此类推直到 0x603320,并将地址值按照输入的数字顺序来排列.
(4)依次取出排列后的地址对应的值,结果必须从大到小排列,输入命令:x/24w 0x6032d0,期望结果如下.
    0x6032d0:    0x0000014c    0x00000001    0x006032e0    0x00000000
    0x6032e0:    0x000000a8    0x00000002    0x00000000    0x00000000
    0x6032f0:    0x0000039c    0x00000003    0x00603300    0x00000000
    0x603300:    0x000002b3    0x00000004    0x00603310    0x00000000
    0x603310:    0x000001dd    0x00000005    0x00603320    0x00000000
    0x603320:    0x000001bb    0x00000006    0x006032d0    0x00000000
(5)反向推导得出答案:3 4 5 6 1 2 => 4 3 2 1 6 5

secret_phase(二叉搜索树):
(1)输入命令:x/s 0x402619 => %d %d %s
(2)输入命令:x/s 0x603870 => 0 0
(3)输入命令:x/s 0x402622 => DrEvil
(4)phase_4 的答案添加 DrEvil 就可以触发该 phase:0 0 DrEvil
(5)伪代码:
   long x = strol("?", 0, 0xa);
   fun7(0x6030f0, x) return 2 => x = 22;
(6)得出答案:22或20

ps:寄存器和跳转指令好多啊,头晕!!!
